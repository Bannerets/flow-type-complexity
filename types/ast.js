// @flow

/* eslint-disable */

// Shit.

/*
 * Partially generated by Flowgen
 * Flowgen v1.2.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

// type BaseNodeWithoutComments = {
//     type: string,
//     loc?: SourceLocation | null,
//     range?: [number, number]
// }
type BaseNode = {
    type: string,
    loc: SourceLocation | null,
    range/*?*/: [number, number]
}// & BaseNodeWithoutComments
export type Node =
    | Identifier
    | Literal
    | Program
    | Function
    | SwitchCase
    | CatchClause
    | VariableDeclarator
    | Statement
    | Expression
    | Property
    | AssignmentProperty
    | Super
    | TemplateElement
    | SpreadElement
    | Pattern
    | ClassBody
    | ClassType
    | MethodDefinition
    | ModuleDeclaration
    | ModuleSpecifier
export type Comment = {
    type: 'Line' | 'Block',
    value: string
}
type SourceLocation = {
    source: string | null,
    start: Position,
    end: Position
}
export type Position = {
    /** >= 1 */
    line: number,
    /** >= 0 */
    column: number
}
export type Program = {
    type: 'Program',
    sourceType: 'script' | 'module',
    body: Array<Statement | ModuleDeclaration>,
    comments: Array<Comment>,
    errors: Array<ParsingError>
} & BaseNode

export type ParsingError = {
    loc: SourceLocation,
    message: string
}

type BaseFunction = {
    params: Array<Pattern>,
    generator?: boolean,
    async?: boolean,
    body: BlockStatement | Expression
} & BaseNode
export type Function = FunctionDeclaration | FunctionExpression | ArrowFunctionExpression
export type Statement =
    | ExpressionStatement
    | BlockStatement
    | EmptyStatement
    | DebuggerStatement
    | WithStatement
    | ReturnStatement
    | LabeledStatement
    | BreakStatement
    | ContinueStatement
    | IfStatement
    | SwitchStatement
    | ThrowStatement
    | TryStatement
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | ForInStatement
    | ForOfStatement
    | Declaration
type BaseStatement = {} & BaseNode
export type EmptyStatement = {
    type: 'EmptyStatement'
} & BaseStatement
export type BlockStatement = {
    type: 'BlockStatement',
    body: Array<Statement>
    // innerComments?: Array<Comment >
} & BaseStatement
export type ExpressionStatement = {
    type: 'ExpressionStatement',
    expression: Expression
} & BaseStatement
export type IfStatement = {
    type: 'IfStatement',
    test: Expression,
    consequent: Statement,
    alternate?: Statement | null
} & BaseStatement
export type LabeledStatement = {
    type: 'LabeledStatement',
    label: Identifier,
    body: Statement
} & BaseStatement
export type BreakStatement = {
    type: 'BreakStatement',
    label?: Identifier | null
} & BaseStatement
export type ContinueStatement = {
    type: 'ContinueStatement',
    label?: Identifier | null
} & BaseStatement
export type WithStatement = {
    type: 'WithStatement',
    object: Expression,
    body: Statement
} & BaseStatement
export type SwitchStatement = {
    type: 'SwitchStatement',
    discriminant: Expression,
    cases: Array<SwitchCase >
} & BaseStatement
export type ReturnStatement = {
    type: 'ReturnStatement',
    argument?: Expression | null
} & BaseStatement
export type ThrowStatement = {
    type: 'ThrowStatement',
    argument: Expression
} & BaseStatement
export type TryStatement = {
    type: 'TryStatement',
    block: BlockStatement,
    handler?: CatchClause | null,
    finalizer?: BlockStatement | null
} & BaseStatement
export type WhileStatement = {
    type: 'WhileStatement',
    test: Expression,
    body: Statement
} & BaseStatement
export type DoWhileStatement = {
    type: 'DoWhileStatement',
    body: Statement,
    test: Expression
} & BaseStatement
export type ForStatement = {
    type: 'ForStatement',
    init?: VariableDeclaration | Expression | null,
    test?: Expression | null,
    update?: Expression | null,
    body: Statement
} & BaseStatement
type BaseForXStatement = {
    left: VariableDeclaration | Pattern,
    right: Expression,
    body: Statement
} & BaseStatement
export type ForInStatement = {
    type: 'ForInStatement'
} & BaseForXStatement
export type DebuggerStatement = {
    type: 'DebuggerStatement'
} & BaseStatement
export type Declaration
    = FunctionDeclaration
    | VariableDeclaration
    | ClassDeclaration
    | TypeAlias

type BaseDeclaration = {} & BaseStatement
export type FunctionDeclaration = {
    type: 'FunctionDeclaration',

    /**
     * It is null when a function declaration is a part of the `export default function` statement
     */
    id: Identifier | null,
    body: BlockStatement
} & BaseFunction & BaseDeclaration
export type VariableDeclaration = {
    type: 'VariableDeclaration',
    declarations: Array<VariableDeclarator>,
    kind: 'var' | 'let' | 'const'
} & BaseDeclaration
export type VariableDeclarator = {
    type: 'VariableDeclarator',
    id: Pattern,
    init?: Expression | null
} & BaseNode
type Expression =
    | ThisExpression
    | ArrayExpression
    | ObjectExpression
    | FunctionExpression
    | ArrowFunctionExpression
    | YieldExpression
    | Literal
    | UnaryExpression
    | UpdateExpression
    | BinaryExpression
    | AssignmentExpression
    | LogicalExpression
    | MemberExpression
    | ConditionalExpression
    | CallExpression
    | NewExpression
    | SequenceExpression
    | TemplateLiteral
    | TaggedTemplateExpression
    | ClassExpression
    | MetaProperty
    | Identifier
    | AwaitExpression
export type BaseExpression = {} & BaseNode
export type ThisExpression = {
    type: 'ThisExpression'
} & BaseExpression
export type ArrayExpression = {
    type: 'ArrayExpression',
    elements: Array<Expression | SpreadElement >
} & BaseExpression
export type ObjectExpression = {
    type: 'ObjectExpression',
    properties: Array<Property >
} & BaseExpression
export type Property = {
    type: 'Property',
    key: Expression,
    value: Expression | Pattern,
    kind: 'init' | 'get' | 'set',
    method: boolean,
    shorthand: boolean,
    computed: boolean
} & BaseNode
export type FunctionExpression = {
    id?: Identifier | null,
    type: 'FunctionExpression',
    body: BlockStatement
} & BaseFunction & BaseExpression
export type SequenceExpression = {
    type: 'SequenceExpression',
    expressions: Array<Expression >
} & BaseExpression
export type UnaryExpression = {
    type: 'UnaryExpression',
    operator: UnaryOperator,
    prefix: void,
    argument: Expression
} & BaseExpression
export type BinaryExpression = {
    type: 'BinaryExpression',
    operator: BinaryOperator,
    left: Expression,
    right: Expression
} & BaseExpression
export type AssignmentExpression = {
    type: 'AssignmentExpression',
    operator: AssignmentOperator,
    left: Pattern | MemberExpression,
    right: Expression
} & BaseExpression
export type UpdateExpression = {
    type: 'UpdateExpression',
    operator: UpdateOperator,
    argument: Expression,
    prefix: boolean
} & BaseExpression
export type LogicalExpression = {
    type: 'LogicalExpression',
    operator: LogicalOperator,
    left: Expression,
    right: Expression
} & BaseExpression
export type ConditionalExpression = {
    type: 'ConditionalExpression',
    test: Expression,
    alternate: Expression,
    consequent: Expression
} & BaseExpression
type BaseCallExpression = {
    callee: Expression | Super,
    arguments: Array<Expression | SpreadElement >
} & BaseExpression
export type CallExpression = SimpleCallExpression | NewExpression;
export type SimpleCallExpression = {
    type: 'CallExpression'
} & BaseCallExpression
export type NewExpression = {
    type: 'NewExpression'
} & BaseCallExpression
export type MemberExpression = {
    type: 'MemberExpression',
    object: Expression | Super,
    property: Expression,
    computed: boolean
} & BaseExpression & BasePattern
export type Pattern =
    | Identifier
    | ObjectPattern
    | ArrayPattern
    | RestElement
    | AssignmentPattern
    | MemberExpression
type BasePattern = {} & BaseNode
export type SwitchCase = {
    type: 'SwitchCase',
    test?: Expression | null,
    consequent: Array<Statement >
} & BaseNode
export type CatchClause = {
    type: 'CatchClause',
    param: Pattern,
    body: BlockStatement
} & BaseNode
export type Identifier = {
    type: 'Identifier',
    name: string
} & BaseNode
export type Literal = SimpleLiteral | RegExpLiteral
export type SimpleLiteral = {
    type: 'Literal',
    value: string | boolean | number | null,
    raw?: string
} & BaseNode & BaseExpression
export type RegExpLiteral = {
    type: 'Literal',
    value?: RegExp | null,
    regex: {
        pattern: string,
        flags: string
    },
    raw?: string
} & BaseNode & BaseExpression
export type UnaryOperator =
    | '-'
    | '+'
    | '!'
    | '~'
    | 'typeof'
    | 'void'
    | 'delete'
export type BinaryOperator =
    | '=='
    | '!='
    | '==='
    | '!=='
    | '<'
    | '<='
    | '>'
    | '>='
    | '<<'
    | '>>'
    | '>>>'
    | '+'
    | '-'
    | '*'
    | '/'
    | '%'
    | '**'
    | '|'
    | '^'
    | '&'
    | 'in'
    | 'instanceof'
export type LogicalOperator = '||' | '&&'
export type AssignmentOperator =
    | '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '**='
    | '<<='
    | '>>='
    | '>>>='
    | '|='
    | '^='
    | '&='
export type UpdateOperator = '++' | '--'
export type ForOfStatement = {
    type: 'ForOfStatement'
} & BaseForXStatement
export type Super = {
    type: 'Super'
} & BaseNode
export type SpreadElement = {
    type: 'SpreadElement',
    argument: Expression
} & BaseNode
export type ArrowFunctionExpression = {
    type: 'ArrowFunctionExpression',
    expression: boolean,
    body: BlockStatement | Expression
} & BaseExpression & BaseFunction
export type YieldExpression = {
    type: 'YieldExpression',
    argument?: Expression | null,
    delegate: boolean
} & BaseExpression
export type TemplateLiteral = {
    type: 'TemplateLiteral',
    quasis: Array<TemplateElement>,
    expressions: Array<Expression >
} & BaseExpression
export type TaggedTemplateExpression = {
    type: 'TaggedTemplateExpression',
    tag: Expression,
    quasi: TemplateLiteral
} & BaseExpression
export type TemplateElement = {
    type: 'TemplateElement',
    tail: boolean,
    value: {
        cooked: string,
        raw: string
    }
} & BaseNode
export type AssignmentProperty = {
    value: Pattern,
    kind: 'init',
    method: boolean
} & Property
export type ObjectPattern = {
    type: 'ObjectPattern',
    properties: Array<AssignmentProperty >
} & BasePattern
export type ArrayPattern = {
    type: 'ArrayPattern',
    elements: Array<Pattern >
} & BasePattern
export type RestElement = {
    type: 'RestElement',
    argument: Pattern
} & BasePattern
export type AssignmentPattern = {
    type: 'AssignmentPattern',
    left: Pattern,
    right: Expression
} & BasePattern
export type ClassType = ClassDeclaration | ClassExpression
type BaseClass = {
    superClass?: Expression | null,
    body: ClassBody
} & BaseNode
export type ClassBody = {
    type: 'ClassBody',
    body: Array<MethodDefinition >
} & BaseNode
export type MethodDefinition = {
    type: 'MethodDefinition',
    key: Expression,
    value: FunctionExpression,
    kind: 'constructor' | 'method' | 'get' | 'set',
    computed: boolean,
    static: boolean
} & BaseNode
export type ClassDeclaration = {
    type: 'ClassDeclaration',

    /**
     * It is null when a class declaration is a part of the `export default class` statement
     */
    id: Identifier | null
} & BaseClass & BaseDeclaration
export type ClassExpression = {
    type: 'ClassExpression',
    id?: Identifier | null
} & BaseClass & BaseExpression
export type MetaProperty = {
    type: 'MetaProperty',
    meta: Identifier,
    property: Identifier
} & BaseExpression
export type ModuleDeclaration = ImportDeclaration | ExportNamedDeclaration | ExportDefaultDeclaration | ExportAllDeclaration
type BaseModuleDeclaration = {} & BaseNode
export type ModuleSpecifier = ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportSpecifier
type BaseModuleSpecifier = {
    local: Identifier
} & BaseNode
export type ImportDeclaration = {
    type: 'ImportDeclaration',
    specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>,
    source: Literal
} & BaseModuleDeclaration
export type ImportSpecifier = {
    type: 'ImportSpecifier',
    imported: Identifier
} & BaseModuleSpecifier
export type ImportDefaultSpecifier = {
    type: 'ImportDefaultSpecifier'
} & BaseModuleSpecifier
export type ImportNamespaceSpecifier = {
    type: 'ImportNamespaceSpecifier'
} & BaseModuleSpecifier
export type ExportNamedDeclaration = {
    type: 'ExportNamedDeclaration',
    declaration?: Declaration | null,
    specifiers: Array<ExportSpecifier>,
    source?: Literal | null
} & BaseModuleDeclaration
export type ExportSpecifier = {
    type: 'ExportSpecifier',
    exported: Identifier
} & BaseModuleSpecifier
export type ExportDefaultDeclaration = {
    type: 'ExportDefaultDeclaration',
    declaration: Declaration | Expression
} & BaseModuleDeclaration
export type ExportAllDeclaration = {
    type: 'ExportAllDeclaration',
    source: Literal
} & BaseModuleDeclaration
export type AwaitExpression = {
    type: 'AwaitExpression',
    argument: Expression
} & BaseExpression

export type FlowTypeAnnotation =
    | AnyTypeAnnotation
    | ArrayTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | BooleanTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumberTypeAnnotation
    | StringLiteralTypeAnnotation
    | StringTypeAnnotation
    | IntersectionTypeAnnotation
    | MixedTypeAnnotation
    | NullableTypeAnnotation
    | TupleTypeAnnotation
    | TypeofTypeAnnotation
    | UnionTypeAnnotation
    | VoidTypeAnnotation
    | NullLiteralTypeAnnotation
    | GenericTypeAnnotation
    | ObjectTypeAnnotation
    | FunctionTypeAnnotation

export type FlowBaseTypeAnnotation = {} & BaseNode
export type FlowBaseLiteralTypeAnnotation = {} & FlowBaseTypeAnnotation & SimpleLiteral
export type FlowBaseDeclaration = {} & BaseDeclaration

export type AnyTypeAnnotation = {
    type: 'AnyTypeAnnotation'
} & FlowBaseTypeAnnotation
export type ArrayTypeAnnotation = {
    type: 'ArrayTypeAnnotation',
    elementType: FlowTypeAnnotation
} & FlowBaseTypeAnnotation
export type BooleanLiteralTypeAnnotation = {
    type: 'BooleanLiteralTypeAnnotation'
} & FlowBaseLiteralTypeAnnotation
export type BooleanTypeAnnotation = {
    type: 'BooleanTypeAnnotation'
} & FlowBaseTypeAnnotation
export type NumberLiteralTypeAnnotation = {
    type: 'NumberLiteralTypeAnnotation'
} & FlowBaseLiteralTypeAnnotation
export type NumberTypeAnnotation = {
    type: 'NumberTypeAnnotation'
} & FlowBaseTypeAnnotation
export type StringLiteralTypeAnnotation = {
    type: 'StringLiteralTypeAnnotation'
} & FlowBaseLiteralTypeAnnotation
export type StringTypeAnnotation = {
    type: 'StringTypeAnnotation'
} & FlowBaseTypeAnnotation
export type IntersectionTypeAnnotation = {
    type: 'IntersectionTypeAnnotation',
    types: Array<FlowTypeAnnotation>
} & FlowBaseTypeAnnotation
export type MixedTypeAnnotation = {
    type: 'MixedTypeAnnotation',
} & FlowBaseTypeAnnotation
export type NullableTypeAnnotation = {
    type: 'NullableTypeAnnotation',
    typeAnnotation: TypeAnnotation
} & FlowBaseTypeAnnotation
export type TupleTypeAnnotation = {
    type: 'TupleTypeAnnotation',
    types: Array<FlowTypeAnnotation >
} & FlowBaseTypeAnnotation
export type TypeofTypeAnnotation = {
    type: 'TypeofTypeAnnotation',
    argument: FlowTypeAnnotation
} & FlowBaseTypeAnnotation
export type UnionTypeAnnotation = {
    type: 'UnionTypeAnnotation',
    types: Array<FlowTypeAnnotation>
} & FlowBaseTypeAnnotation
export type VoidTypeAnnotation = {
    type: 'VoidTypeAnnotation'
} & FlowBaseTypeAnnotation
export type NullLiteralTypeAnnotation = {
    type: 'NullLiteralTypeAnnotation'
} & FlowBaseLiteralTypeAnnotation
export type GenericTypeAnnotation = {
    type: 'GenericTypeAnnotation',
    id: Identifier, // | QualifiedTypeIdentifier,
    typeParameters?: TypeParameterInstantiation | null
} & FlowBaseTypeAnnotation
export type ObjectTypeAnnotation = {
    type: 'ObjectTypeAnnotation',
    properties: Array<ObjectTypeProperty>,
    indexers: Array<ObjectTypeIndexer>,
    callProperties: Array<ObjectTypeCallProperty>
} & FlowBaseTypeAnnotation
export type FunctionTypeAnnotation = {
    type: 'FunctionTypeAnnotation',
    params: Array<FunctionTypeParam>,
    returnType: FlowTypeAnnotation,
    rest?: FunctionTypeParam | null,
    typeParameters?: TypeParameterDeclaration | null
} & FlowBaseTypeAnnotation

export type ClassImplements = {
    id: Identifier,
    typeParameters?: TypeParameterInstantiation | null
} & BaseNode
export type ClassProperty = {
    key: Expression,
    value?: Expression | null,
    typeAnnotation?: TypeAnnotation | null,
    computed: boolean,
    static: boolean
}
export type DeclareClass = {
    id: Identifier,
    typeParameters?: TypeParameterDeclaration | null,
    body: ObjectTypeAnnotation,
    extends: Array<InterfaceExtends >
} & FlowBaseDeclaration
export type DeclareFunction = {
    id: Identifier
} & FlowBaseDeclaration
export type DeclareModule = {
    id: Literal | Identifier,
    body: BlockStatement
} & FlowBaseDeclaration
export type DeclareVariable = {
    id: Identifier
} & FlowBaseDeclaration
export type FunctionTypeParam = {
    name: Identifier,
    typeAnnotation: FlowTypeAnnotation,
    optional: boolean
}
export type InterfaceExtends = {
    id: Identifier | QualifiedTypeIdentifier,
    typeParameters?: TypeParameterInstantiation | null
} & BaseNode
export type InterfaceDeclaration = {
    id: Identifier,
    typeParameters?: TypeParameterDeclaration | null,
    extends: Array<InterfaceExtends>,
    body: ObjectTypeAnnotation
} & FlowBaseDeclaration
export type TypeAlias = {
    type: 'TypeAlias',
    id: Identifier,
    typeParameters?: TypeParameterDeclaration | null,
    right: FlowTypeAnnotation
} & FlowBaseDeclaration
export type TypeAnnotation = {
    typeAnnotation: FlowTypeAnnotation
} & BaseNode
export type TypeCastExpression = {
    expression: Expression,
    typeAnnotation: TypeAnnotation
} & BaseExpression
export type TypeParameterDeclaration = {
    params: Array<Identifier >
} & BaseNode
export type TypeParameterInstantiation = {
    params: Array<FlowTypeAnnotation >
} & BaseNode
export type ObjectTypeCallProperty = {
    value: FunctionTypeAnnotation,
    static: boolean
} & BaseNode
export type ObjectTypeIndexer = {
    id: Identifier,
    key: FlowTypeAnnotation,
    value: FlowTypeAnnotation,
    static: boolean
} & BaseNode
export type ObjectTypeProperty = {
    key: Expression,
    value: FlowTypeAnnotation,
    optional: boolean,
    static: boolean
} & BaseNode
export type QualifiedTypeIdentifier = {
    qualification: Identifier | QualifiedTypeIdentifier,
    id: Identifier
} & BaseNode
